# Decompilation Knowledge: November 2022

## Compiler Patterns

### -proc Flag Variations
- Using `-proc 750` can sometimes fix `mtlr` swaps on unmodified 1.2.5 compiler (vetroidmania, 2022-11-15)
- `-proc 604` enables different scheduling behavior that fixes some functions (revosucks, 2022-11-19)
- The proc flags likely enable/disable specific "flags" in the compiler related to pipeline delay targets or if/else scheduling decisions
- Because `-proc` is a pragma, it can be applied manually per-function to work around scheduling issues

### Scheduler Problem Investigation
- The 1.2.5 scheduler bug: "The scheduler may, with certain instruction patterns, decide to move code below the de-allocation of the current stack frame. That is, code is moved below the `addi sp, sp, N`." (from official Metrowerks update notes)
- The `CW_Update.zip` hotfix is speculated to contain build 167 (1.2.5 is ~b163)
- encounter started reverse engineering the scheduler code; found the generalized configuration lives in per-target tables
- ninji is working on a full mwcc decompilation using Pro7 (has full symbols, no scheduling) and Pro8 (symbols + partial debug info, uses scheduling)
- The mwcc decomp is targeting OS X build and compiles itself (pro7 was built with itself)

### mwcc Decompilation Project (ninji)
- Repository: https://git.wuffs.org/MWCC
- Version being decompiled: CW Pro7 2.4.5 for Mac PPC
- Compiler flags used: `mwccppc -c -g -opt l=4,noschedule,speed -enum min -w all,nounused -wchar_t on -bool off -Cpp_exceptions off`
- Key files of interest:
  - `InstrSelection.c` - code generator with one function per AST node, contains division patterns
  - `CExpr.c` and `CExpr2.c` - likely largest TUs
  - `CMachine.c` - machine configuration
- Trick: x86 builds can provide insight into difficult-to-match functions since return statement handling differs (x86 returns immediately, PPC branches to epilogue)

### Inline and Scheduling Interactions
- Using `-inline auto` with Frank's scheduling patch can introduce extra instructions after prologues in some unrolled loops (werewolf.zip)
- The mere presence of an inline can change the prologue (e.g., adding extra `addi` in prologue) without affecting later code

## Matching Techniques

### getFighter Inline Cast Pattern
- Many fighter functions require a cast after `getFighter()` to match correctly
- Pattern: `Fighter* fp = (void*)getFighter(fighter_gobj);` or `Fighter* fp = (Fighter*)getFighter(fighter_gobj);`
- The cast "fixes" codegen because `user_data` in GObj is `void*`
- Different functions may need different cast variations:
  - Some work with `(void*)` cast
  - Some work with `(Fighter*)` cast
  - Some work with neither
- An inline wrapper for `Fighter_GetModelScale` was discovered to work for multiple functions:
```c
inline float _Fighter_GetModelScale(void *ft) {
    return Fighter_GetModelScale(ft);
}
```

### Special Attributes Access Pattern (sa union debate)
- Long discussion about whether `fighter.h` should use unions for special attributes or just `char[0x100]` buffer with casts
- Arguments for unions: Direct access like `fp->sa.ness.x222C`
- Arguments for casting buffer: Better dependency isolation, each character only knows their own attrs
- Casting approach works and matches:
```c
// In fighter.h
char sa[0x100];

// In character code
ftPeachAttributes* attrs = (ftPeachAttributes*)fp->sa;
```
- Using temp variables for cast can affect codegen around function calls (may invoke savegpr)
- Macro approach: `MY_ATTRS(fp)` that does the cast inline per-access

### Chained Assignment for Flags
- Chained flag assignments can fix matches:
```c
gproc->flags_1 = gproc->flags_2 = 0;  // Instead of separate assignments
```

### Unused Stack Space Solutions
- Extra stack space often indicates missing temps or inlines
- Using temp variables for flag initialization can eliminate unused stack:
```c
s32 init_flag1_2 = 0;
s32 init_flag3 = 3;
gproc->flags_1 = gproc->flags_2 = init_flag1_2;
gproc->flags_3 = init_flag3;
```

### Inline Allocation Pattern (HSD style)
- HSD functions do ObjAlloc and null check in the same inline:
```c
static inline struct HSD_GObjProc *HSD_GObjProcAlloc(void) {
    struct HSD_GObjProc* gproc;
    gproc = (struct HSD_GObjProc*)HSD_ObjAlloc(&gobjproc_alloc_data);
    if (gproc == NULL) {
        __assert("gobjproc.c", 0x1FU, "gproc");
    }
    return gproc;
}
```

### VecClear/VecSet Usage
- `HSD_VecSet(Vec *v, float x, float y, float z)` exists and inlines
- Can help match functions with extra stack by replacing manual vector initialization

## Type Information

### Fighter Struct Key Offsets
- `x2C` - facing_direction
- `x34_scale.z` - model scale (z component)
- `x222C` (0x100 bytes) - special attributes buffer (`sa`), character-specific variables
- `x2234`, `x2238`, etc. - character-specific within sa buffer
- `x2340` - variables that reset on action state change
- `x2D4` - pointer to read-only special attributes (from Pl__.dat files)

### GObj/GObjProc Structure
```c
struct HSD_GObjProc {
    // ...
    u8 s_link;      // priority
    u8 flags_1;
    u8 flags_2;
    u8 flags_3;
    HSD_GObj* owner;   // x10
    void (*on_invoke)(HSD_GObj*);  // x14
};
```

### Item/Article Structure
- Articles are items spawned by users (fighter items, stage items)
- Chain item article pointer in Sheik: accessed via `item_gobj->user_data->xC4_articleData->x4_specialAttributes->x48`
- Article data accessed through `item.h`

### ftHitVictim Array
- Hit victim array has 12 elements (used in collision detection loops)
- Accessed at `hit->x74_victim[i]`

## Function-Specific Insights

### func_8038FD54 (GObj_AddProc/GObj_CreateProcWithCallback)
- Creates and links a GObjProc to a GObj
- Signature: `struct HSD_GObjProc* func_8038FD54(HSD_GObj* gobj, void (*func)(HSD_GObj*), u8 pri)`
- The `pri` parameter is NOT passed to the callback; it's used to order the proc in the linked list

### func_8038FAA8 (GObj_LinkProc)
- Links a proc to its GObj and associates it with the proc table
- Orders by priority in the linked list
- Does NOT receive priority as a parameter

### Fighter_UpdateModelScale
- Matched using inline pattern for scale initialization:
```c
inline void Fighter_InitScale(Fighter *fp, Vec *scale, f32 modelScale) {
    if (fp->x34_scale.z != 1.0f)
        scale->x = fp->x34_scale.z;
    else
        scale->x = modelScale;
    scale->y = modelScale;
    scale->z = modelScale;
}
```

### HUD Functions with addic
- Some HUD functions check if subroutine pointers are non-NULL using `addic.` before branching
- Possibly vestigial from when HUDs used RELs (werewolf.zip theory)
- Or could be missing parentheses on function call causing function pointer comparison (ninji)

## Tool Tips

### Ninja Build System
- 2-3x faster than Make for full rebuilds on some systems
- Much faster for no-change rebuilds: `0.010s` vs `0.113s` (Make)
- On Windows: ninja ~7s vs make ~31s (stark difference)
- Uses `deps = gcc` to cache dependency files internally
- mwcc depfiles don't work on Linux due to backslash separators; need transform-deps.py script

### decomp.me Tips
- Remember to copy the function label with the ASM - "unsupported non-nop instruction outside of function (mflr $r0)" error means you forgot the label
- Error messages may be truncated from m2c

### git bisect
- `git bisect run make` is useful for finding regressions

### Map Generation
- Using `.L` prefix for jump labels (instead of `lbl_`) prevents them from being placed in the map
- Halves map size, shaved a full minute off CI builds (epochflame, Pikmin)

### Dependency Files
- mwcc can generate depfiles but they use backslashes on Windows
- Pikmin/Prime have scripts to fix them for Linux

## Pitfalls and Gotchas

### mwld Patch Required
- `CWParserSetOutputFileDirectory` bug: reads 64 bytes of uninitialized memory and throws error if it contains `/\:*?"<>|`
- Fix: Run `tools/mwld_patch.py`
- Triggered more often with wibo than wine due to stack frame layout
- Check `mwld_prepatch.sha1` and `mwld_postpatch.sha1` to verify patch applied

### Include Syntax
- Don't use `#include "file.h"` (relative imports) in Melee - MWCC doesn't have `-gccinc` flag in 1.2.5
- Don't use `#pragma once` - stick to include guards
- `-once` compiler option would make code incompatible with gcc/modern compilers

### Clean Builds Required
- Make gets confused if you delete a header - do clean rebuild
- Errors like "No rule to make target 'include/...'" often fixed by clean build

### Reserved Identifiers
- Leading underscores in identifiers are reserved (ribbanya)
- Doxygen gets confused if typedef name differs from tag name
- Recommendation: Use `typedef struct Type Type` instead of `typedef struct _Type Type`

## Code Style Conventions (discussed)

### Naming Conventions
- HAL used snake_case for struct members (e.g., `ground_or_air`)
- HAL used camelCase for function names (e.g., `itGetKind`)
- Lower camelCase for smaller/static functions
- Local variables in asserts: abbreviations (`fp`, `o`) or snake_case
- Project uses upper camel with module prefixes for functions (`ftBlahblah_`)

### Character Names (HAL-speak)
- Purin = Jigglypuff (keeping)
- Seak = Sheik (debated)
- Mars = Marth (debated)
- GKoops/Gkoopa = Giant Koopa (Giga Bowser) - from PlGk.dat
- AirCatch = Zair
- Emblem = Roy (though strings say Roy, module is Emblem)
- Crezy = Crazy (HAL phonetic spelling)
- PK Flush (instead of Flash)
- mato = target

### Struct Naming
- Ongoing debate: `typedef struct _Foo Foo;` vs `typedef struct Foo Foo;`
- Leading underscore convention exists for historical/pre-standardization compatibility
- Either works; project moving toward `typedef struct Type Type`

## Project Progress (November 2022)
```
Code sections: 476736 / 3882272 bytes (12.28%)
Data sections: 62539 / 1223369 bytes (5.11%)
35 of 293 Trophies, 2 of 51 Event Matches
```

## Notable Scratches Referenced
- func_80117D9C fix: https://decomp.me/scratch/v6uGe
- sa casting examples: https://decomp.me/scratch/yfOzx, https://decomp.me/scratch/qLMg1
- G&W Neutral B (difficult): https://decomp.me/scratch/P7Z9j, https://decomp.me/scratch/kFkx6
- GObjProc alloc: https://decomp.me/scratch/PxWX7
- Fighter proc patterns: https://decomp.me/scratch/dUUbD, https://decomp.me/scratch/plaCE
- Grab collision check: https://decomp.me/scratch/KQhCQ
- Hitbox detection: https://decomp.me/scratch/sN0Ib
