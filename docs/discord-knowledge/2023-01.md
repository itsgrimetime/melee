# Decompilation Knowledge: 2023-01

Distilled from 1,632 messages in #smash-bros-melee during January 2023.

## Compiler Patterns

### ASM Function Disables Peephole Optimization
- Defining a function as `asm` changes code generation for subsequent loading of pointers to that function
- This is actually a bug in older CodeWarrior versions where an asm function turns peephole optimization off for the rest of the file
- **Workaround**: Wrap asm functions in `#pragma push` / `#pragma pop` or use `#pragma peephole on` after the asm function
- Source: seekyct, altimor (2023-01-01)

### Pragma Once Not Supported
- `#pragma once` does not work with mwcc (at least the version used for Melee)
- Must use traditional include guards instead
- Source: rtburns (2023-01-05)

### Inline Stack Allocation Behavior
- When you invoke an inline function, it typically increments stack allocation in **8-byte increments**, not 4 like regular variables
- This is important for matching functions that have unexplained extra stack space
- Source: revosucks (2023-01-13)

### MWCC Treats int as 1 or 4 Bytes
- MWCC treats `int` as either 1 or 4 bytes depending on the situation
- This explains some of the `long` vs `int` confusion in matches
- Source: ribbanya (2023-01-13)

### MWCC Const and Value Reuse
- MWCC has logic where it tries to reuse values where possible (e.g., reading the same struct field twice in same expression, it'll only fetch once)
- This logic is heavily influenced by the `const` qualifier
- Removing constness via a macro cast can change this optimization behavior
- Source: ninji (2023-01-13)

### unsigned int vs int Codegen Differences
- `s32` matches, `int` doesn't match, `unsigned int` matches in some cases
- The signedness affects code generation even when the value is never negative
- Sometimes a function returning an enum needs to return `unsigned int` to match
- Source: ribbanya, rtburns (2023-01-11)

### C99 Pragma
- MWCC has `#pragma c99 on | off | reset` but it appears to be partially implemented
- No `_Bool` support in Melee's compiler version
- Source: ribbanya (2023-01-17)

### optimizewithasm Pragma
- `#pragma optimizewithasm` allows mwcc to optimize inline assembly (on by default)
- Can lead to unexpected results; disable it with `#pragma optimizewithasm off`
- Used in Metroid Prime decomp to prevent unintended reordering
- Source: antidote6212 (2023-01-16)

### Frank.py False Positives/Negatives
- Frank.py handles li/lwz reordering but NOT li/lmw reordering
- Can cause false negatives where code appears to match but has instruction reordering issues
- Source: altafen, encounter (2023-01-30-31)

## Matching Techniques

### User Data Access Pattern - Major Discovery
- **Critical finding**: The correct pattern for accessing fighter/item user data is:
  ```c
  Fighter* fp = (Fighter*)HSD_GObjGetUserData(fighter_gobj);
  ```
- NOT using `getFighter()` macro directly
- The explicit cast + inline getter is what HAL used
- This pattern fixes stack allocation issues and eliminates many fake matches in fighter.c
- Verified by Smash 64 decomp which shows identical pattern
- Source: rtburns, revosucks (2023-01-11, 2023-01-13)

### HSD_GObjGetHSDObj Pattern
- Similarly, HSD object access should use:
  ```c
  HSD_JObj* jobj = (HSD_JObj*)HSD_GObjGetHSDObj(fighter_gobj);
  ```
- Using this pattern eliminates silly temp variables and fixes stack issues
- Source: rtburns, revosucks (2023-01-11)

### Const Parameter for Inlines
- Adding `const` to inline function parameters can help with matching:
  ```c
  static inline void* HSD_GObjGetUserData(HSD_GObj* const gobj)
  {
      return gobj->user_data;
  }
  ```
- Source: ribbanya (2023-01-13)

### Callback Comparison Pattern
- Some callbacks need a weird comparison pattern to match:
  ```c
  void (*cb_EnterAir)(HSD_GObj*);
  cb_EnterAir = item_data->xB8_itemLogicTable->x20_callback_EnterAir;
  !cb_EnterAir;  // This statement needed for match
  if (cb_EnterAir != NULL) {
      cb_EnterAir(item_gobj);
  }
  ```
- However, this is often a fake match that can be fixed by using proper inline accessors
- Source: rtburns (2023-01-11)

### Double JObj Access Pattern
- Some functions have a weird pattern where jobj is assigned twice:
  ```c
  HSD_JObj* jobj = (HSD_JObj*)HSD_GobjGetHSDObj(fighterObj);
  // ...
  jobj = (HSD_JObj*)HSD_GobjGetHSDObj(fighterObj);
  ```
- This usually implies an inline somewhere, but the standard inline rules don't apply (inlines reserve 8-byte increments, not 4)
- This is still an unsolved mystery for some functions
- Source: revosucks, ribbanya (2023-01-13)

### Variable Declaration Order
- Declaring variables in a specific order can affect register allocation
- The decomp-permuter tool can help brute-force these orderings
- Source: prakxo, camthesaxman (2023-01-10)

### getSizeVar Return Type
- Functions returning enums may need `unsigned int` return type to match even when checking against negative values
- Source: ribbanya, rtburns, vetroidmania (2023-01-11)

## Type Information

### Ground/Stage/Map Naming
- HAL uses specific terminology:
  - **Ground** (`gp`): The user_data struct for stage entities, analogous to Fighter (`fp`) and Item (`ip`)
  - **Stage**: A composition of multiple Grounds
  - **Map**: A specific type/subclass of Ground
- Ground struct is a god struct with unions, similar to Fighter:
  ```c
  gp->u.map.*      // Map ground type
  gp->u.scroll.*   // Scrolling ground type (Rainbow Cruise)
  gp->u.car.*      // F-Zero car type
  gp->u.carnull.*  // F-Zero car collision
  gp->u.taru.*     // Barrel type (DK stages)
  ```
- Size is approximately 0x204 bytes
- Source: rtburns, ribbanya (2023-01-17)

### Item_Struct Naming
- HAL actually called it `Item_Struct` based on assert strings:
  ```c
  OSReport("===== Not Found Item_Struct!! =====\n");
  ```
- Source: ribbanya (2023-01-13)

### HSD Types vs Dolphin Types
- HAL had their own types header, not using standard Dolphin types
- They likely used `u32` as `unsigned int` while Dolphin's `u32` was `unsigned long`
- This explains many matching issues
- HAL may not have used `s32` types at all in Sysdolphin, only `int` for indexes and `u[size]` for unsigned
- Source: werewolf.zip, ribbanya (2023-01-11)

### BOOL Types
- `BOOL` in Melee is 32-bit (`s32`)
- `GXBOOL` in dolphin/gx is `u8`
- Some bool-returning functions may actually return `int` based on context
- Source: ribbanya, vetroidmania (2023-01-13)

### Bitfield Storage
- When you set all bits in a bitfield to false at once, MW may store a full word worth of zeros
- Bitfields are probably not in typedef structs in the original code
- Source: vetroidmania (2023-01-10)

## Function-Specific Insights

### Fighter Callbacks
- Callbacks like `x21DC_callback_OnTakeDamage`, `x21E4_callback_OnDeath2` etc. are set via helper functions
- Example from Samus:
  ```c
  inline void ftSamus_updateDamageDeathCBs(HSD_GObj* fighterObj) {
      Fighter* fighter = Fighter_GetFighter(fighterObj);
      fighter->cb.x21DC_callback_OnTakeDamage = &ftSamus_80128428;
      fighter->cb.x21E4_callback_OnDeath2 = &ftSamus_80128428;
  }
  ```
- Source: revosucks (2023-01-15)

### Fighter_UpdateModelScale
- Final correct version:
  ```c
  void Fighter_UpdateModelScale(HSD_GObj* fighter_gobj)
  {
      Fighter* fp = (Fighter*)HSD_GObjGetUserData(fighter_gobj);
      HSD_JObj* jobj = (HSD_JObj*)HSD_GObjGetHSDObj(fighter_gobj);
      Vec scale;
      f32 modelScale = Fighter_GetModelScale(fp);

      if (fp->x34_scale.z != 1.0f)
          scale.x = fp->x34_scale.z;
      else
          scale.x = modelScale;

      scale.y = modelScale;
      scale.z = modelScale;

      HSD_JObjSetScale(jobj, &scale);
  }
  ```
- Source: revosucks (2023-01-13)

### ftlib Module Pattern
- `*lib` files (e.g., `ftlib`) contain public functions to interact with the module
- Calls from `item.c` go to `ftlib.c`, not other files in `ft`
- Source: ribbanya (2023-01-13)

### Samus Extender Code Location
- The Samus grapple beam/extender code is in `asm/melee/it/code_8027CF30.s` at `lbl_802B7E34`
- Function: `Item_GrappleBeam_Startup`
- Source: rtburns (2023-01-10)

### Tether Code Location
- Tether code shared by Links and Samus is in `ft_unknown_006`
- This file contains a lot of character-specific code beyond the 341 common states
- Source: ribbanya (2023-01-10)

### NaN Position Check
- Debug code checks for NaN positions:
  ```c
  if (g_debugLevel >= 3) {
      if (fpclassify(fp->xB0_pos.x) == FP_NAN ||
          fpclassify(fp->xB0_pos.y) == FP_NAN ||
          fpclassify(fp->xB0_pos.z) == FP_NAN)
      {
          OSReport("fighter procMap pos error.\tpos.x=%f\tpos.y=%f\n",
                   fp->xB0_pos.x, fp->xB0_pos.y);
          __assert(__FILE__, 2590, "0");
      }
  }
  ```
- Source: revosucks (2023-01-13)

### Dead Code / Typos in Original
- Some original code has what appears to be typos:
  ```c
  void func_803755A8(void)
  {
      // Does nothing, but need to force a comparison to make this match
      if (current_render_pass == HSD_RP_OFFSCREEN)
          current_render_pass == 0;  // Typo: == instead of =
  }
  ```
- Source: ribbanya (2023-01-10)

## Tool Tips

### objdiff
- objdiff is great for local development - diffs as soon as you save the C file
- Recommended over asm-differ for iterative development
- Easy to set up with cargo
- Source: ribbanya (2023-01-11)

### Decomp.me Context Generation
- Use `tools/generate_context.sh` or the pinned context
- Context needs all headers that would be included by the source file
- AT_ADDRESS macro needs special handling for permuter compatibility (use FIXEDADDR syntax)
- Source: various (2023-01-12)

### gcc -E for Context
- Using `gcc -E -dM` can generate contexts with preprocessor defines included
- Useful for getting all macro definitions
- Source: rtburns (2023-01-12)

### pcpp (Python C Preprocessor)
- pcpp has `passthru-defines` options that are perfect for context generation
- Can preserve macros while still preprocessing
- Source: rtburns, ribbanya (2023-01-13)

### include-what-you-use
- Tool for fixing transitive include issues
- https://include-what-you-use.org/
- Source: rtburns (2023-01-12)

### clang-format Version
- LLVM 15 fixes several clang-format bugs including:
  - Pointer alignment with inline struct declarations
  - `AfterControlStatement: MultiLine` issues
- Source: rtburns (2023-01-03)

### -requireprotos Flag
- mwcc flag that requires function prototypes before use
- Essential for catching missing declarations
- Source: ribbanya (2023-01-06)

### Decomp Progress Calculation
- Progress script scans source files for asm function regex
- If the name appears in map file, subtracts that symbol's size from progress
- Source: ribbanya (2023-01-09)

### clang-format off for asm
- Place `// clang-format off` before asm blocks to prevent formatting issues:
  ```c
  // clang-format off
  asm u32 PPCMfmsr(void)
  {
      // asm code
  }
  // clang-format on
  ```
- Source: rtburns, ribbanya (2023-01-17)

### Negative Float Literals in ASM
- Inline asm doesn't support negative float literals directly
- **Workaround**: Define a const float and reference it:
  ```c
  const float whatever = -1.0f;
  // use 'whatever' in asm
  ```
- Source: camthesaxman (2023-01-17)

## Pitfalls and Gotchas

### __FILE__ in Matches
- Renaming files affects `__FILE__` macro, causing DOL mismatches
- Discovered when renaming `ftyoshi.c` broke the build
- Source: ribbanya (2023-01-21)

### getFighter() is Wrong Pattern
- Using the `getFighter()` macro directly produces incorrect codegen
- Must use `(Fighter*)HSD_GObjGetUserData()` pattern instead
- All existing getFighter usages need to be converted
- Source: revosucks (2023-01-13, 2023-01-28)

### Double Inline Stack Issue
- Having a double inline (e.g., `Fighter_GetFighter` calling `HSD_GObjGetUserData`) can cause stack issues
- The smallest fighter.c function that accesses user_data cannot get small enough stack with double inline
- Source: revosucks (2023-01-15)

### functions.h is Problematic
- functions.h was considered a mistake - causes maintenance nightmare
- Inline extern functions in it should be removed
- Should use `-requireprotos` flag in Makefile instead
- Source: rtburns, ribbanya (2023-01-02-03)

### Mixed C/ASM Constant Reuse
- No good workaround for sharing constants between C and inline asm in the same file
- Source: altimor, ribbanya (2023-01-02)

### Commits Must Individually Compile
- Each commit in a PR should compile and match
- Otherwise `git bisect run make` becomes impossible
- Source: ribbanya (2023-01-03)

### generate_context.sh Issues
- Had issues with Windows paths, `is_relative_to` attribute errors on older Python
- May need to remove normalization on some setups
- Wine association needed on Linux for mwcc
- Source: various (2023-01-12, 2023-01-15)

### Hitbox Terminology
- Community calls them "hitboxes" but they're actually capsules (two spheres connected by cylinder)
- Similar misconception happened in OoT (thought they were spheres, turned out to be cylinders)
- Same with Tekken 7 (modders thought spheres, actually cylinders)
- Source: ribbanya, revosucks, altimor (2023-01-28)

### C++ Incompatibilities
- `= { 0 }` for struct initialization doesn't work in C++ (need `= { }`)
- May need `extern "C"` for porting
- Source: werewolf.zip (2023-01-09)

### Melee64 Code Similarity
- Smash 64 and Melee share design patterns (not code)
- Fighter pointer casting pattern is identical
- Proof that the cast+inline access is correct
- Source: revosucks (2023-01-10)

## Project Status Notes

### Progress as of Late January 2023
- Code sections: 558405 / 3882272 bytes (14.38%)
- Data sections: 146256 / 1223369 bytes (11.96%)
- 41 of 293 Trophies milestone
- About 10% progress gained in the past year
- Source: revosucks, altafen (2023-01-24, 2023-01-31)

### Dolphin SDK Remaining
- Largest remaining: vi.s, jpeg/jpegdec.s, pad/Pad.s
- Most data sections can likely be removed
- Plan to move to shared external repo
- Source: rtburns (2023-01-16)

### Brawl Not Useful for Melee
- Brawl is C++ rewrite by Sora Ltd, not HAL
- Completely different codebase, not useful for Melee
- Source: revosucks (2023-01-13)
