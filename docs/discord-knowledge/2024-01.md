# Decompilation Knowledge: 2024-01

This document distills technical knowledge shared in the #smash-bros-melee Discord channel during January 2024. It covers compiler behavior, matching techniques, type discoveries, and tooling tips.

## Compiler Patterns

### Variadic Functions (va_args) and Parameter Counting

The mwcc compiler uses `lis r0, 0xN00` to indicate the number of initial parameters in variadic functions, where N is incremented by 0x100 per parameter.

Example pattern discovered by werewolf.zip:
```c
void lbArchive_80016AF0(HSD_Archive* archive, void** file, ...) {
    char* symbols;
    va_list sections;

    va_start(sections, archive);
    for (; file != NULL; file = va_arg(sections, void**)) {
        symbols = va_arg(sections, char*);
        *file = NULL;
        *file = HSD_ArchiveGetPublicAddress(archive, symbols);
        if (*file == NULL) {
            OSReport("Cannot find symbol %s.\n", symbols);
        }
    }
    va_end(sections);
}
```

- `va_start` behavior: mwcc seems to ignore the second parameter and always generates the code properly
- Using `for` instead of `while` can be necessary to skip the first iteration when matching
- Source: werewolf.zip (2024-01-17/18)

### Ternaries vs If/Else

Ternaries generate different code than equivalent if/else statements:
- Ternaries create a temporary variable for the result (always in saved registers or stack at O0)
- This helps the compiler when ternaries are part of complex expressions
- With optimization, these temporaries are often discarded
- In mwcc 1.0-1.2.5, the stack space left behind by temporaries is not always cleaned up
- Source: gamemasterplc, revosucks (2024-01-17)

### Float/Int Parameter Ordering

Floating point values go in different registers (FPRs) than integer/pointer values (GPRs). The ordering of FP arguments relative to non-FP arguments doesn't matter for matching, as long as each type's arguments maintain their correct relative ordering.

Example: A function may appear as `function(GObj*, u32, GObj*, f32, f32, f32, f32)` in code but the parameter order in the declaration can vary as long as FPR and GPR orderings are preserved independently.
- Source: werewolf.zip (2024-01-18)

### Inline Function Emission

When a function is declared `inline` (not `static inline`):
- It gets embedded into each TU where it's used
- The linker deduplicates these, so it ends up in a "random" TU (usually `lb_*` files)
- This is why some functions appear at unexpected locations in the linker order
- Without `static`, regular inline functions get deduplicated by the linker
- Source: rtburns (2024-01-17)

### Auto-Inlining and Stack Issues

HAL used an auto-inlining mode (`-inline auto`). Most stack issues in Melee come from how this works:
- Static functions in the same TU can get inlined and removed
- They leave stack allocations behind even when the function is removed
- Source: revosucks (2024-01-17)

### Extab/Extabindex in Sysdolphin

Some parts of sysdolphin appear to be compiled with C++ exceptions enabled, even though the project uses `-Cpp_exceptions off`. This was likely a compiler bug where the flag was ignored.
- Source: werewolf.zip (2024-01-17)

## Matching Techniques

### Jump Tables and Switch Statements

Jump tables (`jtbl_t`) in the codebase are placeholders for switch statements:
- When you see a table of function addresses with computed offsets, it's usually a switch statement
- The compiler creates jump tables for switches with many cases near zero
- After bounds checking, it indexes into the table and branches directly
- The `jtbl_t` type is a "fakematch" for a switch statement
- Source: muff1n1634, ribbanya (2024-01-01)

### saved_in_reg_rx Errors

When you see `saved_in_reg_rx` errors in decompiled output, it almost always means there's a missing parameter or return value:
- Missing r3 typically means a function is `void` when it should return an `int` or pointer
- Source: ribbanya (2024-01-12)

### Chained Assignments

For vector initializations:
- `z = 0; y = 0; x = 0;` is usually the same codegen as `x = y = z = 0;`
- Exception: with bitfields involved, chaining may produce different results
- Source: ribbanya (2024-01-15)

### Inline Wrapper Trick

When facing register allocation issues, wrapping operations in an inline function can fix them:
```c
static inline double sqrtf_wrapper(f32 val) {
    return (double)sqrtf_accurate(val);
}
```
Changing return types from `float` to `double` can also fix stack alignment issues.
- Source: rtburns, revosucks (2024-01-16)

### Bitfield Access

Bitfields are accessed via bit manipulation (`value >> n & MASK`):
- The compiler figures out the equivalent bitshift operation
- Loads the whole byte/word and manipulates bits as necessary
- The `: 1` syntax in struct definitions specifies exact bit widths
- Unions are for convenience to access whole values or individual bits
- Source: ribbanya (2024-01-21)

### True vs 1 for Bitfields

Using `true` instead of `1` for bitfield assignments can affect matching:
```c
// May produce different codegen:
spawnitem.x44_flag.bits.b0 = true;  // vs
spawnitem.x44_flag.bits.b0 = 1;
```
- Source: altafen (2024-01-15)

### Extern Float Constants

When you see `extern f32 it_804DD188;` in context, it's typically an inline float constant (like `0.0f`). Sometimes using the literal vs the extern makes no difference, but try both.
- Source: altafen (2024-01-15)

## Type Information

### Melee Bug Discovery: Null Check Inversion

werewolf.zip discovered a bug in Melee's particle code where the null check is inverted:
```c
gp = pp->gen;
if (gp == NULL) {  // BUG: Should be != NULL
    *x = gp->x;    // Reads from address 0x24 when gp is NULL!
    *y = gp->y;
    *z = gp->z;
    return;
}
```
The result is that when `gp` is NULL, it loads from RAM addresses 0x24, 0x28, and 0x2C. This was fixed in K7.
- Source: werewolf.zip (2024-01-11)

### File/Module Naming Conventions

```
cm - Camera
db - Debug
ef - (Visual) effects
ft - Fighters
gm - Game (main game loop)
gr - Ground (stages and other levels)
if - Interface, UI
it - Items
lb - Library, utility functions
mn - Menus
mp - Map (stage-related)
pl - Players (as in users)
sc - Scene
ty - Toy (trophies)
un - Unknown (not an actual original folder)
vi - Visual (cutscenes)
```
- Source: ribbanya (2024-01-11)

### Vi Files (Visual/Cutscene Data)

```
Vi0102.dat: Mario & Luigi cutscene (Adventure Mode)
Vi0401.dat: Brinstar cutscene 1 (Intro)
Vi0402.dat: Brinstar cutscene 2 (Explosion/Exit)
Vi0501.dat: Green Greens cutscene 1 (Intro)
Vi0502.dat: Green Greens cutscene 2 (Giant Kirby)
Vi0601.dat: Corneria cutscene (Adventure Mode)
Vi0801.dat: F-Zero Grand Prix cutscene (Adventure Mode)
Vi1101.dat: Mario/Luigi Metal Bros. cutscene
Vi1201v1.dat: Bowser outro scene (Adventure Mode)
Vi1201v2.dat: Giga Bowser intro scene (Adventure Mode)
Vi1202.dat: Giga/Bowser defeated/outro
```
- Source: .durgan, werewolf.zip (2024-01-10)

### Unsplit/Unnamed Files

Files with addresses in their names (like `lb_00B0`, `lb_00CE`) are functionally unsplit blobs with unknown original names:
- `lb_00CE` - Probably `lbmath` (contains expf and powf)
- `lb_0192` - DVD status checking, video/text rendering, SI stuff
- `lb_0198` - Multiple lbcard stuff (actually unsplit)
- `pl_0371` - Stale move management (could be `plstale.c`)
- Source: revosucks, werewolf.zip (2024-01-17)

## Function-Specific Insights

### lbArchive Functions

`lbArchive_80016AF0` loads file sections from archives:
```c
lbArchive_80016AF0(archive, &title_ptrs.top_joint, "TtlMoji_Top_joint",
    &title_ptrs.top_animjoint, "TtlMoji_Top_animjoint", ...);
```
Takes pairs of (pointer to store result, symbol name string), terminated by NULL.
- Source: werewolf.zip (2024-01-17)

### sqrtf Implementation

The original MSL sqrtf from `math_ppc.h` uses Newton-Raphson iterations:
```c
extern inline float sqrtf(float x)
{
    static const double _half=.5;
    static const double _three=3.0;
    volatile float y;
    if(x > 0.0f) {
        double guess = __frsqrte((double)x);
        guess = _half*guess*(_three - guess*guess*x);  // 12 sig bits
        guess = _half*guess*(_three - guess*guess*x);  // 24 sig bits
        guess = _half*guess*(_three - guess*guess*x);  // 32 sig bits
        y=(float)(x*guess);
        return y;
    }
    return x;
}
```
The `sqrtf_accurate` function adds an extra iteration for >32 significant bits.
- Source: revosucks, rtburns (2024-01-16, 2024-01-27)

### GET_FIGHTER Macro

- Use `GET_FIGHTER(gobj)` or `fighter_gobj->user_data` for fighter access
- Do NOT use `getFighterPlus` - it's a fake match that consumes stack
- Source: altafen, ribbanya (2024-01-24)

## Tool Tips

### decomp.me

For creating scratches with `.L` labels (local labels):
- m2c needed an update to recognize `.L` as a label prefix instead of a macro
- PR #269 to m2c added support for this
- Use the `dump` branch for m2c-compatible syntax
- Source: .durgan, encounter (2024-01-18)

### Local Development Setup

Run m2c locally:
```sh
python tools/decomp.py function_name
python tools/decomp.py --colorize $fn_name --valid-syntax --no-casts
python tools/decomp.py $fn_name --gotos-only  # When logic is messy
```

Run asm-differ:
```sh
python tools/asm-differ/diff.py -3woms --width 40 "func_name"
python tools/asm-differ/diff.py -woms function_name
```
- Source: ribbanya (2024-01-25)

### objdiff Setup

objdiff is the recommended local diffing tool:
1. Install from releases or `cargo install --git https://github.com/encounter/objdiff.git`
2. Run `python configure.py && ninja`
3. Open your melee folder in objdiff
4. Add TUs to `config/GALE01/splits.txt` for diffing
- Source: ribbanya (2024-01-20)

### DTK (Decomp Toolkit) Notes

DTK split configuration:
- Splits should include alignment padding
- Set split end to where the next symbol starts
- Use `data:string` to tell DTK a symbol is a string
- When a symbol shows `scope:local` but has `_{address}` suffix, it was "globalized" (referenced from another TU due to wrong split)
- Source: encounter, werewolf.zip (2024-01-16)

DTK with make:
- `-cwd source` flag makes mwcc search for includes starting from the source file's directory
- Different from `-gccinc` in newer mwcc
- Source: ribbanya, encounter (2024-01-17)

### MUST_MATCH Macro

- `MUST_MATCH` is for forcing C files to link with make
- No longer needed with dtk/objdiff workflow
- Being phased out
- Source: ribbanya (2024-01-24)

### IWYU Pragmas for Include Checking

Use IWYU pragmas to fix false positives in include checking:
```c
#include <melee/sc/forward.h> // IWYU pragma: export
```
- Source: altafen (2024-01-24)

### Windows-Specific Issues

- Python subprocess needs `executable=sys.executable` to find the correct venv Python
- m2ctx needs to specify `encoding='utf-8'` when writing files (defaults to ANSI on Windows)
- asm-differ needs `tail.exe` and `less.exe` on PATH (or use `--no-pager`)
- Source: altafen (2024-01-24, 2024-01-28)

## Pitfalls and Gotchas

### Progress Calculation Bug

Splitting files can cause the progress script to report incorrect values:
- After splitting un_2FC9.s into smaller files, progress dropped ~6KB
- The calcprogress.py script has accuracy issues with slices
- Source: werewolf.zip, ribbanya (2024-01-09)

### DTK ASSERT Line Numbers

When using DTK, `HSD_ASSERT` line numbers can get shifted if `MUST_MATCH` is not defined:
```c
// Without MUST_MATCH, line 489 might report as 0xf8 instead of 0x1e9
HSD_ASSERT(489, new);
```
Solution: Add `MUST_MATCH` to configure.py defines.
- Source: werewolf.zip, ribbanya (2024-01-16)

### Common Section Behavior

In older GCC/mwcc, uninitialized data like `int counter;` (without `static`) goes into a "common" section that the linker deduplicates. This is different from functions and initialized data which cause multiple definition errors.
- Source: gamemasterplc (2024-01-17)

### Stack Variable "Fake Matches"

When adding stack padding to match:
- Could indicate missing inline function calls
- Could indicate wrong parameter types (e.g., function takes `Vec3*` but you're passing `f32*`)
- The padding may be "real" if adjacent stack variables are accessed by an inlined function
- Not always UB - often just compiler inefficiency
- Source: revosucks, rtburns (2024-01-24)

### Struct Field Access Bug Pattern

When you see code loading from wrong offsets, check for typos in variable names:
```c
// Bug: Uses gp instead of pp
*x = gp->x;  // Should be pp->x
```
This can make it look like the struct is wrong when it's actually a code bug.
- Source: werewolf.zip (2024-01-11)

## Build System Notes

### Transition to DTK

The project transitioned from make+asm to ninja+dtk in January 2024:
- No more need for asm files in repo (eventually)
- objdiff replaces asm-differ for most use cases
- Partial linking no longer needed - objdiff handles partial matches
- Files can be "unlinked" in configure.py and worked on incrementally
- Source: ribbanya, altafen (2024-01-24-27)

### Recommended Build Commands

```sh
# Basic build
python configure.py && ninja

# Build all source files (even unlinked)
ninja all_source

# Build with diff on failure
(ninja && ninja all_source) || ninja diff
```
- Source: ribbanya, altafen (2024-01-27)

### Compiler/Linker Versions

- Compiler: mwcc 1.2.5n for most code
- Linker: mwld 1.3.2 works (1.1 had a bug with uninitialized path data)
- The mwld 1.1 bug was fixed in 1.2.5
- Source: altafen, ribbanya (2024-01-26)
