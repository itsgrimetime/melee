# Decompilation Knowledge: December 2022

This document distills tribal knowledge from the #smash-bros-melee Discord channel during December 2022. This was a productive month with significant progress on understanding user_data access patterns, BSS ordering, and various compiler behaviors.

## Compiler Patterns

### int vs s32 (long) Codegen Differences

Using `int` instead of `s32` can dramatically change codegen, even though they're the same size:

- `s32` is defined as `long`, while `int` is just `int`
- The compiler treats them as different types internally, causing implicit casts
- Implicit casts can affect stack allocation - the compiler may temporarily allocate stack space for cast results
- Example: `int` types can consume more stack space than `s32` due to implicit conversion overhead

Source: rtburns, revosucks (2022-12-17)

```c
// This implicit cast can affect codegen:
void bar(s32 myS32) {
    int foo = myS32; // implicit cast from long to int
}
```

### BSS Variable Ordering

BSS variables are ordered based on usage order, not declaration order:

- Using `static` keyword forces variables to be placed in BSS in declaration order
- Without `static`, order depends on first reference/usage in code
- Can force order by creating a dummy function that references variables in desired order:

```c
// From SMB1 - forces BSS ordering
#define FORCE_BSS_ORDER(var) void *_force_bss_order_##var(){return &var;}
```

- Alternatively, initializing with `= {}` can force order, but this moves data to .data section instead of .bss

Source: altimor, revosucks, rtburns (2022-12-24)

### Inline Stack Consumption

Adding inline functions sometimes increases stack allocation unexpectedly:

- The compiler may allocate stack space for inline parameters even when optimizing them away
- Getting the "inner stack" (locations within a function) vs "outer stack" (total prologue/epilogue allocation) to match requires understanding these behaviors
- Wrapping entire functions in inlines can sometimes fix stack mismatches

Source: revosucks, ninji (2022-12-17)

### Loop Strength Reduction

The compiler performs "strength reduction" on loop variables:

- If every iteration uses something derived from the iteration variable, the compiler creates extra temporaries
- It will increment these by the derived amount each iteration
- Different array strides (e.g., 4 bytes vs 8 bytes) can create multiple temporary variables

Source: ninji (2022-12-27)

```c
// Compiler may generate code tracking both 'bone' and 'offset' separately:
bone += 1;
*(u32*)((int)&player->bones->jobj + offset) = 0;
offset += 0x10;
```

### Enum Sizing with -enum int

- The `-enum int` flag makes enums 32-bit by default
- Without it, enums become `u8`
- Can control enum size by adding extra values (e.g., any negative value makes it signed)
- Some HSD functions truncate masks to 16 bits, which may indicate inconsistent enum handling

Source: vetroidmania, ninji (2022-12-26)

### Loop Unrolling Control

Use `#pragma ppc_unroll_instructions_limit 1` to disable the loop unroller for clearer codegen analysis.

Source: ninji (2022-12-25)

## Matching Techniques

### User Data Access Patterns (getFighter)

Major discovery: HAL likely used a consistent pattern for accessing gobj user_data:

```c
inline void* HSD_GobjGetUserData(HSD_GObj* gobj) {
    return gobj->user_data;
}

#define GET_FIGHTER(gobj) ((Fighter*)HSD_GobjGetUserData(gobj))
```

Key findings:
- The cast `(Fighter*)` is required, not optional - it affects regalloc and stack allocation
- Both `(void*)getFighter()` and `(Fighter*)getFighter()` patterns exist
- Direct `gobj->user_data` access vs the macro produces different codegen
- The `fp = fp = getFighter(gobj)` double assignment was a known fakematch that got fixed with proper access patterns

Source: revosucks, ribbanya, altimor (throughout December)

### Condition Splitting

Splitting compound conditions can fix matches:

```c
// Instead of:
if ((temp_r0 != 0U) &&
    (func_800C0A28(fighter_gobj, temp_r0, p->unk4) != 0) &&
    (p->f_unk8(temp_r0, fighter_gobj, (f32*)&floats_on_stack) != 0))

// Try splitting:
if (p->unk0) {
    if ((func_800C0A28(fighter_gobj, temp_r0, p->unk4) != 0) &&
        (p->f_unk8(temp_r0, fighter_gobj, (f32*)&floats_on_stack) != 0)) {
```

Source: chippy__ (2022-12-23)

### Wrapper Functions for Inlining

Some functions are wrappers that inline their entire body into another function:

```c
// The "setBit" inline solved a recursive function matching problem
inline void setBit(HSD_GObj* gobj) {
    Fighter* fp = (Fighter*)getFighter(gobj);
    fp->x2219_flag.bits.b7 = 1;
}
```

- When a function recursively calls itself, using getFighter can bloat the stack 3x
- Assignment within function call can force specific codegen: `setBit(newgobj = fp->x1A5C);`

Source: revosucks, chippy__ (2022-12-02)

### Switch vs If/Else Detection

Tightly-knit if/else comparisons are often unrolled switches:

- The compiler may generate similar code for both
- Reordering switch cases affects comparison order in generated code
- For unsigned variables, `case < 1` implies `case 0`
- Use `-sym on` in compiler options to see line-to-instruction mapping

Source: revosucks (2022-12-02)

### Temporary Variable Elimination

After getting m2c output to compile, eliminate as many temporaries as possible:

- 90% of the time, cleaned-up output matches better
- The decompiler adds cruft that doesn't represent original code
- The compiler tends to lookahead (peephole optimization) and may early-load variables

Source: revosucks (2022-12-02)

## Type Information

### x2070 Union in Fighter Struct

Confirmed union at offset 0x2070 in Fighter:

```c
union Struct2070 {
    struct {
        s8 x2070;
        u8 x2071_b0_3: 4;
        u8 x2071_b4: 1;
        u8 x2071_b5: 1;
        u8 x2071_b6: 1;
        u8 x2071_b7: 1;
        u8 x2072_b0_3: 4;
        u8 x2072_b4: 1;
        u8 x2072_b5: 1;
        u8 x2072_b6: 1;
        u8 x2072_b7: 1;
        u8 x2073;
    };
    s32 x2070_int;
};
```

This was proven by:
- Stack write of s32 followed by bytewise reads
- The union access pattern allows both packed field access and single s32 read

Source: revosucks, ninji (2022-12-02)

### Fighter Allocation Sizes

From `HSD_ObjAllocInit` calls in fighter.c:

| Variable | Size | Contents |
|----------|------|----------|
| lbl_80458FD0 | 0x23EC | sizeof(Fighter) |
| lbl_80458FFC | 0x424 | CharacterSpecialStats |
| lbl_80459028 | 0x8C0 | ftCommonData / Bones |
| lbl_80459054 | 0x1F0 | DObjList |
| lbl_80459080 | 0x80 | Unknown |
| lbl_804590AC | varies | FigaTree data |

Source: altimor, revosucks, ribbanya (2022-12-24)

### State Variables vs Special Attributes

- `x222C` (SpecialAttrs) are "fighter vars" - more permanent storage that persists across action states
- `x2340` (StateVars) are temporary vars used by current action state, wiped on state change
- Example: Mewtwo's Shadow Ball charge is at x222C so it persists, while Ness's Yo-Yo animation frame goes to x2340

Source: vetroidmania (2022-12-09)

### Hitbox Struct Union at 0x138

Discovered potential union at offset 0x138:
- Contains both `HSD_GObj*` and `u8 : 1` (1-bit field)
- Unless fighters use two different hitbox structs

Source: vetroidmania (2022-12-25)

## Function-Specific Insights

### Fighter_UnkRecursiveFunc_8006D044

Recursive functions require special handling:

- Using getFighter in recursive calls bloats stack 3x
- Solution involved inline setBit function with assignment in call
- Direct `gobj->user_data` access was necessary in one spot despite getFighter usage elsewhere

Source: revosucks, ribbanya (2022-12-02)

### func_80031640 (cm/cmsnap)

This is a switch statement, not if/else chains:
- The variable type being unsigned matters for case detection
- `case < 1` on unsigned means case is 0

Source: revosucks, giginss (2022-12-02)

### func_80291DAC - Infinite Super Scope Glitch

The function is expected to return `s32` but when the infinite super scope glitch occurs:
- If the loop completes without breaking, it skips the `mr r3,r8` return
- r3 remains the input parameter (offset 0x1974 of fighter's user_data - pointer to held item)
- This is how the bug manifests at the code level

Source: vetroidmania (2022-12-11)

### G&W Bacon (Neutral B)

Extremely difficult to match:
- Always either one regswap or one-two instructions away
- Possible undefined behavior somewhere
- Using `int` instead of `s32` changes codegen drastically but creates other issues

Source: vetroidmania (2022-12-25)

## Tool Tips

### decomp.me Usage

- Target ASM should be just the function, not the whole file
- Delete `#include macros.inc` line from target ASM
- For jump table functions, include both `.rodata` and `.text` sections
- Use `-sym on` compiler flag to see line number mappings
- If decompilation fails, it won't show target ASM - try compiling empty function first
- Export button provides .zip with .s file

### Permuter with decomp.me Support

r-burns has a fork with rebased inline support + decomp.me import:
https://github.com/r-burns/decomp-permuter/tree/import-decompme-rebased

### mwcc Dependency Files

- mwcc's dep file output has issues (always outputs to working dir)
- The project uses gcc to generate deps instead
- mwcc deps work on Windows but not Linux without encounter's fix tool

### Linker Issues

Error: `Unexpected error in CWParserSetOutputFileDirectory [3]`
- Known edge case on some setups
- Fix: Change linker to 1.2.5 in Makefile, or run `python tools/mwld_patch.py`

Source: revosucks, ribbanya (2022-12-20)

## Pitfalls and Gotchas

### Shiftability Breaking

Hardcoded addresses in ASM files break shiftability:
- `.4byte` with literal addresses (string literals, floats)
- `asm/melee/mp/mpcoll.s` has this issue with `__FILE__` literal
- Solutions: extern from C or compute from base address

Source: rtburns, ribbanya (2022-12-14)

### s32 unused[n] Anti-Pattern

Never use `s32 unused[2]` to pad stack - this is a fakematch:
- Find the real cause of stack differences
- Often indicates incorrect inline usage or wrong access patterns

Source: revosucks, ribbanya (2022-12-02)

### sizeof Hardcoding

Don't hardcode allocation sizes:
```c
// Bad:
HSD_ObjAllocInit(&lbl_80458FD0, /*size*/0x23ec, /*align*/4);

// Good:
HSD_ObjAllocInit(&FighterAllocData, sizeof(Fighter), 4);
```

Source: altimor (2022-12-23)

### Cast Significance

Explicit vs implicit casts matter to mwcc:
- `(Fighter*)void*` vs `(void*)Fighter*` can produce different codegen
- The presence of a cast is more important than the specific type in some cases
- Cast results may allocate temporary stack space even if optimized away

Source: altimor, revosucks (2022-12-24)

### Static Variable Initialization

Using `= {}` on static variables:
- Forces BSS ordering but moves to .data section
- May be needed for certain functions to match (func_8006DABC)
- Can affect subsequent functions that see the definitions

Source: revosucks (2022-12-24)

## Historical Notes

### Progress Tracking

- The website showed incorrect progress (14.89%) due to tracking inlined ASM
- Actual progress was ~12.7% code, ~5.2% data
- Trophy/Event Match metaphor: Trophies = code progress, Events = data progress
- End of month: 40 of 293 Trophies, 2 of 51 Event Matches

### Dolphin SDK Dates

- Melee's Dolphin SDK: Sep 2001
- Zoids VS: Dec 2001 (uses 1.2.5e)
- Prime: Sep 2002 (has some source changes)
- Some libs use 1.2.5e while others use vanilla 1.2.5

Source: rtburns (2022-12-17)

### Killer7 Leak

Contains HSD structs and function/parameter names in DWARF debug info. Policy discussion ongoing about usage.

Source: altimor (2022-12-26)

## Code Style Decisions

- Line length: 80 columns (decided by consensus)
- Pointer style: `void* ptr` (left-aligned)
- Brace style: K&R for control structures, Allman for functions
- clang-format: Used for consistency, but include sorting disabled to preserve inline ordering

Source: ribbanya, altimor (2022-12-26)
